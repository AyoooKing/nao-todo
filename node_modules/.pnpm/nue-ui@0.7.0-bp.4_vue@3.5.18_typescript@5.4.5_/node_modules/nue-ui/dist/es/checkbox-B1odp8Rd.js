import { g as e, p as l, w as a } from "./utils-D3GAsA1N.js";
import { defineComponent as u, inject as t, computed as o, onMounted as n, onBeforeUnmount as s, openBlock as i, createElementBlock as r, normalizeClass as d, createVNode as c, createElementVNode as m, renderSlot as v, createTextVNode as p, toDisplayString as h, ref as f, provide as b, watch as g, withCtx as k, createCommentVNode as x } from "vue";
import { _ as V } from "./icon-DKepx2gf.js";
import { i as C } from "./vendor-DtiFC3Pk.js";
const _ = "CheckboxGroupCtx", y = { class: "nue-checkbox__label" }, N = u({ name: "NueCheckbox", __name: "checkbox", props: { modelValue: { type: Boolean, default: void 0 }, label: {}, name: { default: e(4) }, size: {}, disabled: { type: Boolean, default: false }, loading: { type: Boolean, default: false }, indeterminate: { type: Boolean }, beforeCheck: {}, theme: {} }, emits: ["update:modelValue", "change", "checked", "unchecked"], setup(e2, { emit: a2 }) {
  const u2 = e2, f2 = a2, b2 = t(_, void 0), g2 = o(() => {
    const { modelValue: e3 } = u2;
    if ("boolean" == typeof e3) return e3;
    if (b2) {
      const { activeNames: e4 } = b2, { name: l2 } = u2;
      return e4.value.includes(l2);
    }
    return false;
  }), k2 = o(() => {
    if (u2.disabled) return true;
    if (b2) {
      const { disabled: e3, maximized: l2, minimized: a3 } = b2;
      return e3 || l2.value && !g2.value || a3.value && g2.value;
    }
    return false;
  }), x2 = o(() => {
    let e3 = [];
    const a3 = "nue-checkbox";
    let { theme: t2, size: o2, loading: n2, indeterminate: s2 } = u2;
    return b2 && (t2 = b2.theme ?? t2, o2 = b2.size ?? o2), e3.push(a3), t2 && (e3 = e3.concat(l(t2, a3))), o2 && e3.push(`${a3}--${o2}`), n2 && e3.push(`${a3}--loading`), k2.value && e3.push(`${a3}--disabled`), (g2.value || s2) && e3.push(`${a3}--checked`), e3;
  }), N2 = o(() => {
    const { label: e3, name: l2 } = u2;
    return e3 ?? l2;
  }), z2 = o(() => {
    const { loading: e3, indeterminate: l2 } = u2;
    return e3 ? "loading" : g2.value ? "square-check-fill" : l2 ? "square-check" : "square";
  }), $2 = async () => {
    const { loading: e3, beforeCheck: l2 } = u2;
    if (!e3 && !k2.value) {
      if (C(l2)) try {
        if (!await l2(g2.value)) return;
      } catch (e4) {
        return e4;
      }
      B2();
    }
  }, B2 = () => {
    const e3 = !g2.value;
    if ("boolean" == typeof u2.modelValue) f2("update:modelValue", e3);
    else {
      if (!b2) return;
      {
        const { name: l2 } = u2;
        b2[e3 ? "pushName" : "popName"](l2);
      }
    }
    f2("change", e3), f2(e3 ? "checked" : "unchecked");
  };
  return n(() => {
    if (!b2) return;
    const { name: e3 } = u2;
    "NueCheckboxGroupController" !== e3 && b2.register(e3);
  }), s(() => {
    b2 && b2.unregister(u2.name);
  }), (e3, l2) => (i(), r("div", { class: d(x2.value), onClick: $2 }, [c(V, { name: z2.value, spin: e3.loading, class: "nue-checkbox__icon" }, null, 8, ["name", "spin"]), m("span", y, [v(e3.$slots, "default", {}, () => [p(h(N2.value), 1)])])], 2));
} }), z = a(N), $ = { class: "nue-checkbox-group" }, B = a(u({ name: "NueCheckboxGroup", __name: "checkbox-group", props: { modelValue: {}, size: {}, disabled: { type: Boolean, default: false }, name: {}, useController: { type: Boolean, default: false }, controllerLabel: {}, min: { default: 0 }, max: { default: 1 / 0 }, theme: {} }, emits: ["update:modelValue"], setup(e2, { emit: l2 }) {
  const a2 = e2, u2 = l2, t2 = f([]), n2 = f([]), s2 = f(false), d2 = f(false), m2 = o(() => !s2.value && !d2.value), V2 = o({ get: () => !!s2.value || !d2.value && n2.value.length >= t2.value.length, set(e3) {
    if (e3) {
      let e4 = 0;
      for (; e4 < t2.value.length && !s2.value; ) {
        const l3 = t2.value[e4++];
        n2.value.includes(l3) || n2.value.push(l3), C2();
      }
    } else for (; !d2.value; ) n2.value.pop(), C2();
    u2("update:modelValue", n2.value);
  } }), C2 = () => {
    s2.value = n2.value.length >= a2.max, d2.value = n2.value.length <= a2.min;
  };
  return b(_, { activeNames: n2, theme: a2.theme, size: a2.size, disabled: a2.disabled, maximized: s2, minimized: d2, pushName: (e3) => !s2.value && !n2.value.includes(e3) && (n2.value.push(e3), u2("update:modelValue", n2.value), C2(), true), popName: (e3) => !d2.value && !!n2.value.includes(e3) && (n2.value = n2.value.filter((l3) => l3 !== e3), u2("update:modelValue", n2.value), C2(), true), register: (e3) => {
    t2.value.includes(e3) || t2.value.push(e3);
  }, unregister: (e3) => {
    t2.value.includes(e3) && (t2.value = t2.value.filter((l3) => l3 !== e3));
  } }), g(() => a2.modelValue, (e3) => n2.value = e3, { immediate: true }), (e3, l3) => (i(), r("div", $, [e3.useController ? v(e3.$slots, "controller", { key: 0, controllerState: V2.value, isIndeterminate: m2.value }, () => [c(N, { modelValue: V2.value, "onUpdate:modelValue": l3[0] || (l3[0] = (e4) => V2.value = e4), indeterminate: m2.value, class: "nue-checkbox-group__controller", name: "NueCheckboxGroupController" }, { default: k(() => [p(h(e3.controllerLabel ?? ""), 1)]), _: 1 }, 8, ["modelValue", "indeterminate"])]) : x("", true), v(e3.$slots, "default")]));
} }));
export {
  z as N,
  B as a
};
