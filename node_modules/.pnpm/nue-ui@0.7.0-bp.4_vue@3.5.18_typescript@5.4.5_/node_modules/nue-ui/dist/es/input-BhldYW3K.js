import { p as e, a as t, d as a, w as o } from "./utils-D3GAsA1N.js";
import { defineComponent as l, computed as n, openBlock as s, createElementBlock as u, toDisplayString as r, ref as i, watch as d, onBeforeUnmount as p, normalizeClass as m, normalizeStyle as c, createBlock as h, unref as f, createCommentVNode as x, createElementVNode as v, withModifiers as b, nextTick as y, onMounted as g } from "vue";
import { b as w } from "./hooks-C1UjnUZ1.js";
import "./avatar-yzliDfrH.js";
import "./badge-_zvsRtW_.js";
import "./button-y8Aj-aBT.js";
import "./checkbox-B1odp8Rd.js";
import "./collapse-C_6fYhZ-.js";
import { N as j } from "./icon-DKepx2gf.js";
import "./text-TjewgIQ-.js";
import "./popup-wrapper-DVF5gLbi.js";
import "./confirm-YE1II1Pa.js";
import "./container-CYKikxGw.js";
import "./dialog-DDQvp2KT.js";
import "./div-Ds7FlWtC.js";
import "./drawer-C_6qrEkP.js";
import "./dropdown-CYLJA7-z.js";
import "./empty-9T0sEZ5j.js";
import "./infinite-scroll-DiID_Y5i.js";
import "./link-V-rQKoXz.js";
import "./progress-CLbjrDiX.js";
import "./prompt-CUXwrUXd.js";
import "./select-KdhfWKua.js";
import "./switch-BMjTISmX.js";
import "./tooltip-CPFII4M3.js";
import "./marquee-3hYdShqd.js";
import "./message-ChzyHR3L.js";
const _ = { class: "word-counter" }, k = l({ name: "WordCounter", __name: "word-counter", props: { mode: { default: "both" }, length: {}, maxlength: { default: 0 } }, setup(e2) {
  const t2 = e2, a2 = n(() => {
    const { mode: e3, maxlength: a3, length: o2 } = t2;
    if ("off" === e3) return false;
    let l2 = "";
    const n2 = -1 !== a3 && a3;
    return "word-left" !== e3 && (l2 += `${o2} / ${n2 || "-"}`), "both" === e3 && (l2 += " , "), "word-limit" !== e3 && (l2 += n2 ? n2 - o2 : "-"), l2;
  });
  return (e3, t3) => (s(), u("div", _, r(a2.value), 1));
} }), V = ["id", "disabled", "maxlength", "name", "placeholder", "readonly", "type", "value"], z = l({ name: "NueInput", __name: "input", props: { type: { default: "text" }, modelValue: {}, id: {}, theme: {}, shape: {}, icon: {}, placeholder: {}, maxlength: {}, disabled: { type: Boolean }, readonly: { type: Boolean }, clearable: { type: Boolean }, allowShowPassword: { type: Boolean }, counter: { default: "off" }, width: {}, size: {}, debounceTime: { default: 0 }, flex: {}, name: {} }, emits: ["update:modelValue", "input", "blur", "change"], setup(o2, { expose: l2, emit: r2 }) {
  const g2 = r2, _2 = o2, z2 = i(), [$2, B2] = w(false), C2 = i(false), I2 = i(0), T = n(() => {
    const t2 = "nue-input", { size: a2, theme: o3, shape: l3, disabled: n2 } = _2;
    let s2 = [];
    return s2.push(t2), a2 && s2.push(`${t2}--${a2}`), l3 && s2.push(`${t2}--${l3}`), o3 && s2.push(...e(o3, t2)), n2 && s2.push(`${t2}--disabled`), s2;
  }), R = n(() => {
    const { width: e2, size: a2, flex: o3 } = _2;
    return { "--width": e2, "--font-size": a2, "--flex": o3 ? t(o3) : void 0 };
  }), N = n(() => {
    const { type: e2, allowShowPassword: t2, modelValue: a2 } = _2;
    return "password" === e2 && t2 && "" !== a2;
  }), q = n(() => {
    const { disabled: e2, readonly: t2, clearable: a2, modelValue: o3 } = _2;
    return !e2 && !t2 && a2 && "" !== o3;
  }), P = a(() => {
    z2.value && g2("update:modelValue", z2.value.value);
  }, _2.debounceTime);
  function S() {
    C2.value = true;
  }
  function H() {
    C2.value = false, P();
  }
  function O() {
    g2("update:modelValue", ""), y(() => {
      z2.value && z2.value.focus();
    });
  }
  const W = d(() => _2.modelValue, (e2) => {
    I2.value = e2.length;
  });
  return p(() => W()), l2({ innerInputRef: z2 }), (e2, t2) => (s(), u("div", { class: m(T.value), style: c(R.value) }, [e2.icon ? (s(), h(f(j), { key: 0, name: e2.icon, class: "nue-input__icon" }, null, 8, ["name"])) : x("", true), v("input", { id: e2.id, ref_key: "inputRef", ref: z2, disabled: e2.disabled, maxlength: e2.maxlength, name: e2.name, placeholder: e2.placeholder, readonly: !e2.disabled && e2.readonly, type: f($2) ? "text" : e2.type, value: e2.modelValue, class: "nue-input__input", onBlur: t2[0] || (t2[0] = (e3) => g2("blur", e3)), onChange: t2[1] || (t2[1] = (e3) => g2("change", e3)), onCompositionend: H, onCompositionstart: S, onInput: t2[2] || (t2[2] = (e3) => {
    return t3 = e3, void (C2.value || (P(), g2("input", t3)));
    var t3;
  }) }, null, 40, V), "number" !== e2.type && "off" !== e2.counter ? (s(), h(k, { key: 1, length: I2.value, maxlength: parseInt(e2.maxlength || "0"), mode: e2.counter }, null, 8, ["length", "maxlength", "mode"])) : x("", true), N.value ? (s(), h(f(j), { key: 2, name: f($2) ? "eye-close" : "eye", class: "nue-input__icon-button", onClick: t2[3] || (t2[3] = b(() => f(B2)(), ["stop"])) }, null, 8, ["name"])) : x("", true), q.value ? (s(), h(f(j), { key: 3, class: "nue-input__icon-button", name: "clear", onClick: b(O, ["stop"]) })) : x("", true)], 6));
} }), $ = ["id", "disabled", "maxlength", "placeholder", "readonly", "rows", "value"], B = l({ name: "NueTextarea", __name: "textarea", props: { modelValue: {}, id: {}, placeholder: {}, theme: {}, shape: {}, disabled: { type: Boolean }, readonly: { type: Boolean }, rows: {}, resize: { type: Boolean }, autosize: { type: [Boolean, Object] }, maxlength: {}, counter: { default: "off" }, width: {}, size: {}, debounceTime: { default: 0 }, flex: {} }, emits: ["update:modelValue", "input", "blur", "change"], setup(t2, { expose: o2, emit: l2 }) {
  const r2 = l2, f2 = t2, b2 = i(), w2 = i(), j2 = i(f2.modelValue.length), _2 = i(false), V2 = n(() => {
    const t3 = "nue-textarea", { size: a2, theme: o3, shape: l3, disabled: n2, readonly: s2 } = f2;
    let u2 = [];
    return u2.push(t3), a2 && u2.push(`${t3}--${a2}`), l3 && u2.push(`${t3}--${l3}`), o3 && u2.push(...e(o3, t3)), n2 && u2.push(`${t3}--disabled`), s2 && u2.push(`${t3}--readonly`), u2;
  }), z2 = n(() => {
    const { autosize: e2, width: t3, rows: a2, resize: o3, flex: l3, disabled: n2 } = f2;
    return { "--rows": o3 || 0 === a2 ? 999 : a2, "--width": t3, "--resize": o3 && !n2 ? "vertical" : void 0, "--flex": l3, "--overflow": e2 ? "hidden" : "auto" };
  }), B2 = a((e2) => r2("update:modelValue", e2), f2.debounceTime);
  function C2(e2) {
    f2.autosize && (w2.value.value = e2, y(() => {
      b2.value.style.height = w2.value.scrollHeight + "px";
    }));
  }
  function I2() {
    const e2 = b2.value.value;
    B2(e2), C2(e2);
  }
  function T() {
    _2.value || I2();
  }
  function R() {
    _2.value = true;
  }
  function N() {
    _2.value = false, I2();
  }
  const q = d(() => f2.modelValue, (e2) => {
    j2.value = e2.length, C2(e2);
  });
  return g(() => C2(f2.modelValue)), p(() => q()), o2({ innerInputRef: b2, backendTextareaRef: w2, update: I2 }), (e2, t3) => (s(), u("div", { class: m(V2.value), style: c(z2.value) }, [v("textarea", { id: e2.id, ref_key: "textareaRef", ref: b2, disabled: e2.disabled, maxlength: e2.maxlength, placeholder: e2.placeholder, readonly: e2.readonly, rows: e2.rows, value: e2.modelValue, class: "nue-textarea__textarea", onBlur: t3[0] || (t3[0] = (e3) => r2("blur", e3)), onChange: t3[1] || (t3[1] = (e3) => r2("change", e3)), onCompositionend: N, onCompositionstart: R, onInput: T }, null, 40, $), !e2.autosize || f2.disabled || f2.readonly ? x("", true) : (s(), u("textarea", { key: 0, ref_key: "backendTextareaRef", ref: w2, class: "nue-textarea__textarea nue-textarea__backend-textarea", readonly: "", tabindex: "-1" }, null, 512)), "off" !== e2.counter ? (s(), h(k, { key: 1, length: j2.value, maxlength: parseInt(e2.maxlength || "0"), mode: e2.counter }, null, 8, ["length", "maxlength", "mode"])) : x("", true)], 6));
} }), C = o(z), I = o(B);
export {
  C as N,
  B as _,
  I as a,
  z as b
};
